1. analize swag and rotation
2. measure tanslation between cam and rotor
3. calibrate each cam
4. tune angle pid
struct CamParams
{
    int rows, cols;
    float cx, cy, fx, fy, fps;
    CamParams(int rows_, int cols_,
                 float cx_,float cy_,
                 float fx_, float fy_,
                 float fps_):
        rows(rows_),cols(cols_),
        cx(cx_),cy(cy_),
        fx(fx_),fy(fy_),
        fps(fps_)
    {}
};
//tf::Vector3 calc_XYZ(tfScalar yaw,tfScalar pitch,tfScalar row,float depth,CamParams &sp,cv::Point &pix_2d)
//{
//  tf::Transform trans;
//  tf::Quaternion quat(yaw,pitch,row);
//  trans.setRotation(quat);

//  trans.setOrigin(tf::Vector3(0,0,0));
//  tf::Vector3 tmpPt;
//  tmpPt.m_floats[0]=depth;
//  tmpPt.m_floats[1]=-(pix_2d.x-sp.cx)*depth/sp.fx;
//  tmpPt.m_floats[2]=-(pix_2d.y-sp.cy)*depth/sp.fy;

//  // to global point
//  tmpPt=trans*tmpPt;
//  return tmpPt;
//}

//    std::vector<cv::Point> point_db;
//    std::vector<tf::Vector3> XYZ_db;
//    point_db.push_back(cv::Point(654,585));
//    CamParams cp(480,640,630.52,495.16,871.34,871.59,10);
//    for(auto &pt:point_db)
//    {
//     XYZ_db.push_back(calc_XYZ(0,31.5/RAD2DEG,0,0.49,cp,pt));
//    }
//    printf("debug to see XYZ");

	vector<Mat> imgChannels;
	split(img_bgr, imgChannels);
	Mat red_channel = imgChannels.at(2);
	Mat blue_channel = imgChannels.at(0);
	Mat mid_chn_img = red_channel - blue_channel;
	threshold(mid_chn_img, img_binary, 70, 255, CV_THRESH_BINARY_INV);

